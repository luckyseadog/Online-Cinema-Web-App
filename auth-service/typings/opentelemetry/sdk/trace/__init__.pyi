"""
This type stub file was generated by pyright.
"""

import abc
import atexit
import concurrent.futures
import json
import logging
import threading
import traceback
import typing
from os import environ
from time import time_ns
from types import MappingProxyType, TracebackType
from typing import Any, Callable, Dict, Iterator, List, MutableMapping, Optional, Sequence, Tuple, Type, Union
from warnings import filterwarnings
from deprecated import deprecated
from opentelemetry import context as context_api, trace as trace_api
from opentelemetry.attributes import BoundedAttributes
from opentelemetry.sdk import util
from opentelemetry.sdk.environment_variables import OTEL_ATTRIBUTE_COUNT_LIMIT, OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT, OTEL_EVENT_ATTRIBUTE_COUNT_LIMIT, OTEL_LINK_ATTRIBUTE_COUNT_LIMIT, OTEL_SDK_DISABLED, OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT, OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT, OTEL_SPAN_EVENT_COUNT_LIMIT, OTEL_SPAN_LINK_COUNT_LIMIT
from opentelemetry.sdk.resources import Resource
from opentelemetry.sdk.trace import sampling
from opentelemetry.sdk.trace.id_generator import IdGenerator, RandomIdGenerator
from opentelemetry.sdk.util import BoundedList
from opentelemetry.sdk.util.instrumentation import InstrumentationInfo, InstrumentationScope
from opentelemetry.semconv.attributes.exception_attributes import EXCEPTION_ESCAPED, EXCEPTION_MESSAGE, EXCEPTION_STACKTRACE, EXCEPTION_TYPE
from opentelemetry.trace import NoOpTracer, SpanContext
from opentelemetry.trace.status import Status, StatusCode
from opentelemetry.util import types
from opentelemetry.util._decorator import _agnosticcontextmanager

logger = ...
_DEFAULT_OTEL_ATTRIBUTE_COUNT_LIMIT = ...
_DEFAULT_OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT = ...
_DEFAULT_OTEL_EVENT_ATTRIBUTE_COUNT_LIMIT = ...
_DEFAULT_OTEL_LINK_ATTRIBUTE_COUNT_LIMIT = ...
_DEFAULT_OTEL_SPAN_EVENT_COUNT_LIMIT = ...
_DEFAULT_OTEL_SPAN_LINK_COUNT_LIMIT = ...
_ENV_VALUE_UNSET = ...
class SpanProcessor:
    """Interface which allows hooks for SDK's `Span` start and end method
    invocations.

    Span processors can be registered directly using
    :func:`TracerProvider.add_span_processor` and they are invoked
    in the same order as they were registered.
    """
    def on_start(self, span: Span, parent_context: Optional[context_api.Context] = ...) -> None:
        """Called when a :class:`opentelemetry.trace.Span` is started.

        This method is called synchronously on the thread that starts the
        span, therefore it should not block or throw an exception.

        Args:
            span: The :class:`opentelemetry.trace.Span` that just started.
            parent_context: The parent context of the span that just started.
        """
        ...
    
    def on_end(self, span: ReadableSpan) -> None:
        """Called when a :class:`opentelemetry.trace.Span` is ended.

        This method is called synchronously on the thread that ends the
        span, therefore it should not block or throw an exception.

        Args:
            span: The :class:`opentelemetry.trace.Span` that just ended.
        """
        ...
    
    def shutdown(self) -> None:
        """Called when a :class:`opentelemetry.sdk.trace.TracerProvider` is shutdown."""
        ...
    
    def force_flush(self, timeout_millis: int = ...) -> bool:
        """Export all ended spans to the configured Exporter that have not yet
        been exported.

        Args:
            timeout_millis: The maximum amount of time to wait for spans to be
                exported.

        Returns:
            False if the timeout is exceeded, True otherwise.
        """
        ...
    


class SynchronousMultiSpanProcessor(SpanProcessor):
    """Implementation of class:`SpanProcessor` that forwards all received
    events to a list of span processors sequentially.

    The underlying span processors are called in sequential order as they were
    added.
    """
    _span_processors: Tuple[SpanProcessor, ...]
    def __init__(self) -> None:
        ...
    
    def add_span_processor(self, span_processor: SpanProcessor) -> None:
        """Adds a SpanProcessor to the list handled by this instance."""
        ...
    
    def on_start(self, span: Span, parent_context: Optional[context_api.Context] = ...) -> None:
        ...
    
    def on_end(self, span: ReadableSpan) -> None:
        ...
    
    def shutdown(self) -> None:
        """Sequentially shuts down all underlying span processors."""
        ...
    
    def force_flush(self, timeout_millis: int = ...) -> bool:
        """Sequentially calls force_flush on all underlying
        :class:`SpanProcessor`

        Args:
            timeout_millis: The maximum amount of time over all span processors
                to wait for spans to be exported. In case the first n span
                processors exceeded the timeout followup span processors will be
                skipped.

        Returns:
            True if all span processors flushed their spans within the
            given timeout, False otherwise.
        """
        ...
    


class ConcurrentMultiSpanProcessor(SpanProcessor):
    """Implementation of :class:`SpanProcessor` that forwards all received
    events to a list of span processors in parallel.

    Calls to the underlying span processors are forwarded in parallel by
    submitting them to a thread pool executor and waiting until each span
    processor finished its work.

    Args:
        num_threads: The number of threads managed by the thread pool executor
            and thus defining how many span processors can work in parallel.
    """
    def __init__(self, num_threads: int = ...) -> None:
        ...
    
    def add_span_processor(self, span_processor: SpanProcessor) -> None:
        """Adds a SpanProcessor to the list handled by this instance."""
        ...
    
    def on_start(self, span: Span, parent_context: Optional[context_api.Context] = ...) -> None:
        ...
    
    def on_end(self, span: ReadableSpan) -> None:
        ...
    
    def shutdown(self) -> None:
        """Shuts down all underlying span processors in parallel."""
        ...
    
    def force_flush(self, timeout_millis: int = ...) -> bool:
        """Calls force_flush on all underlying span processors in parallel.

        Args:
            timeout_millis: The maximum amount of time to wait for spans to be
                exported.

        Returns:
            True if all span processors flushed their spans within the given
            timeout, False otherwise.
        """
        ...
    


class EventBase(abc.ABC):
    def __init__(self, name: str, timestamp: Optional[int] = ...) -> None:
        ...
    
    @property
    def name(self) -> str:
        ...
    
    @property
    def timestamp(self) -> int:
        ...
    
    @property
    @abc.abstractmethod
    def attributes(self) -> types.Attributes:
        ...
    


class Event(EventBase):
    """A text annotation with a set of attributes. The attributes of an event
    are immutable.

    Args:
        name: Name of the event.
        attributes: Attributes of the event.
        timestamp: Timestamp of the event. If `None` it will filled
            automatically.
    """
    def __init__(self, name: str, attributes: types.Attributes = ..., timestamp: Optional[int] = ..., limit: Optional[int] = ...) -> None:
        ...
    
    @property
    def attributes(self) -> types.Attributes:
        ...
    
    @property
    def dropped_attributes(self) -> int:
        ...
    


class ReadableSpan:
    """Provides read-only access to span attributes.

    Users should NOT be creating these objects directly. `ReadableSpan`s are created as
    a direct result from using the tracing pipeline via the `Tracer`.

    """
    def __init__(self, name: str, context: Optional[trace_api.SpanContext] = ..., parent: Optional[trace_api.SpanContext] = ..., resource: Optional[Resource] = ..., attributes: types.Attributes = ..., events: Sequence[Event] = ..., links: Sequence[trace_api.Link] = ..., kind: trace_api.SpanKind = ..., instrumentation_info: Optional[InstrumentationInfo] = ..., status: Status = ..., start_time: Optional[int] = ..., end_time: Optional[int] = ..., instrumentation_scope: Optional[InstrumentationScope] = ...) -> None:
        ...
    
    @property
    def dropped_attributes(self) -> int:
        ...
    
    @property
    def dropped_events(self) -> int:
        ...
    
    @property
    def dropped_links(self) -> int:
        ...
    
    @property
    def name(self) -> str:
        ...
    
    def get_span_context(self): # -> SpanContext | None:
        ...
    
    @property
    def context(self): # -> SpanContext | None:
        ...
    
    @property
    def kind(self) -> trace_api.SpanKind:
        ...
    
    @property
    def parent(self) -> Optional[trace_api.SpanContext]:
        ...
    
    @property
    def start_time(self) -> Optional[int]:
        ...
    
    @property
    def end_time(self) -> Optional[int]:
        ...
    
    @property
    def status(self) -> trace_api.Status:
        ...
    
    @property
    def attributes(self) -> types.Attributes:
        ...
    
    @property
    def events(self) -> Sequence[Event]:
        ...
    
    @property
    def links(self) -> Sequence[trace_api.Link]:
        ...
    
    @property
    def resource(self) -> Resource:
        ...
    
    @property
    @deprecated(version="1.11.1", reason="You should use instrumentation_scope")
    def instrumentation_info(self) -> Optional[InstrumentationInfo]:
        ...
    
    @property
    def instrumentation_scope(self) -> Optional[InstrumentationScope]:
        ...
    
    def to_json(self, indent: int = ...): # -> str:
        ...
    


class SpanLimits:
    """The limits that should be enforce on recorded data such as events, links, attributes etc.

    This class does not enforce any limits itself. It only provides an a way read limits from env,
    default values and from user provided arguments.

    All limit arguments must be either a non-negative integer, ``None`` or ``SpanLimits.UNSET``.

    - All limit arguments are optional.
    - If a limit argument is not set, the class will try to read its value from the corresponding
      environment variable.
    - If the environment variable is not set, the default value, if any, will be used.

    Limit precedence:

    - If a model specific limit is set, it will be used.
    - Else if the corresponding global limit is set, it will be used.
    - Else if the model specific limit has a default value, the default value will be used.
    - Else if the global limit has a default value, the default value will be used.

    Args:
        max_attributes: Maximum number of attributes that can be added to a span, event, and link.
            Environment variable: OTEL_ATTRIBUTE_COUNT_LIMIT
            Default: {_DEFAULT_ATTRIBUTE_COUNT_LIMIT}
        max_events: Maximum number of events that can be added to a Span.
            Environment variable: OTEL_SPAN_EVENT_COUNT_LIMIT
            Default: {_DEFAULT_SPAN_EVENT_COUNT_LIMIT}
        max_links: Maximum number of links that can be added to a Span.
            Environment variable: OTEL_SPAN_LINK_COUNT_LIMIT
            Default: {_DEFAULT_SPAN_LINK_COUNT_LIMIT}
        max_span_attributes: Maximum number of attributes that can be added to a Span.
            Environment variable: OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT
            Default: {_DEFAULT_OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT}
        max_event_attributes: Maximum number of attributes that can be added to an Event.
            Default: {_DEFAULT_OTEL_EVENT_ATTRIBUTE_COUNT_LIMIT}
        max_link_attributes: Maximum number of attributes that can be added to a Link.
            Default: {_DEFAULT_OTEL_LINK_ATTRIBUTE_COUNT_LIMIT}
        max_attribute_length: Maximum length an attribute value can have. Values longer than
            the specified length will be truncated.
        max_span_attribute_length: Maximum length a span attribute value can have. Values longer than
            the specified length will be truncated.
    """
    UNSET = ...
    def __init__(self, max_attributes: Optional[int] = ..., max_events: Optional[int] = ..., max_links: Optional[int] = ..., max_span_attributes: Optional[int] = ..., max_event_attributes: Optional[int] = ..., max_link_attributes: Optional[int] = ..., max_attribute_length: Optional[int] = ..., max_span_attribute_length: Optional[int] = ...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


_UnsetLimits = ...
SPAN_ATTRIBUTE_COUNT_LIMIT = ...
class Span(trace_api.Span, ReadableSpan):
    """See `opentelemetry.trace.Span`.

    Users should create `Span` objects via the `Tracer` instead of this
    constructor.

    Args:
        name: The name of the operation this span represents
        context: The immutable span context
        parent: This span's parent's `opentelemetry.trace.SpanContext`, or
            None if this is a root span
        sampler: The sampler used to create this span
        trace_config: TODO
        resource: Entity producing telemetry
        attributes: The span's attributes to be exported
        events: Timestamped events to be exported
        links: Links to other spans to be exported
        span_processor: `SpanProcessor` to invoke when starting and ending
            this `Span`.
        limits: `SpanLimits` instance that was passed to the `TracerProvider`
    """
    def __new__(cls, *args, **kwargs): # -> Self:
        ...
    
    def __init__(self, name: str, context: trace_api.SpanContext, parent: Optional[trace_api.SpanContext] = ..., sampler: Optional[sampling.Sampler] = ..., trace_config: None = ..., resource: Optional[Resource] = ..., attributes: types.Attributes = ..., events: Optional[Sequence[Event]] = ..., links: Sequence[trace_api.Link] = ..., kind: trace_api.SpanKind = ..., span_processor: SpanProcessor = ..., instrumentation_info: Optional[InstrumentationInfo] = ..., record_exception: bool = ..., set_status_on_exception: bool = ..., limits=..., instrumentation_scope: Optional[InstrumentationScope] = ...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def get_span_context(self): # -> SpanContext | None:
        ...
    
    def set_attributes(self, attributes: Dict[str, types.AttributeValue]) -> None:
        ...
    
    def set_attribute(self, key: str, value: types.AttributeValue) -> None:
        ...
    
    def add_event(self, name: str, attributes: types.Attributes = ..., timestamp: Optional[int] = ...) -> None:
        ...
    
    def add_link(self, context: SpanContext, attributes: types.Attributes = ...) -> None:
        ...
    
    def start(self, start_time: Optional[int] = ..., parent_context: Optional[context_api.Context] = ...) -> None:
        ...
    
    def end(self, end_time: Optional[int] = ...) -> None:
        ...
    
    @_check_span_ended
    def update_name(self, name: str) -> None:
        ...
    
    def is_recording(self) -> bool:
        ...
    
    @_check_span_ended
    def set_status(self, status: typing.Union[Status, StatusCode], description: typing.Optional[str] = ...) -> None:
        ...
    
    def __exit__(self, exc_type: Optional[Type[BaseException]], exc_val: Optional[BaseException], exc_tb: Optional[TracebackType]) -> None:
        """Ends context manager and calls `end` on the `Span`."""
        ...
    
    def record_exception(self, exception: BaseException, attributes: types.Attributes = ..., timestamp: Optional[int] = ..., escaped: bool = ...) -> None:
        """Records an exception as a span event."""
        ...
    


class _Span(Span):
    """Protected implementation of `opentelemetry.trace.Span`.

    This constructor exists to prevent the instantiation of the `Span` class
    by other mechanisms than through the `Tracer`.
    """
    ...


class Tracer(trace_api.Tracer):
    """See `opentelemetry.trace.Tracer`."""
    def __init__(self, sampler: sampling.Sampler, resource: Resource, span_processor: Union[SynchronousMultiSpanProcessor, ConcurrentMultiSpanProcessor], id_generator: IdGenerator, instrumentation_info: InstrumentationInfo, span_limits: SpanLimits, instrumentation_scope: InstrumentationScope) -> None:
        ...
    
    @_agnosticcontextmanager
    def start_as_current_span(self, name: str, context: Optional[context_api.Context] = ..., kind: trace_api.SpanKind = ..., attributes: types.Attributes = ..., links: Optional[Sequence[trace_api.Link]] = ..., start_time: Optional[int] = ..., record_exception: bool = ..., set_status_on_exception: bool = ..., end_on_exit: bool = ...) -> Iterator[trace_api.Span]:
        ...
    
    def start_span(self, name: str, context: Optional[context_api.Context] = ..., kind: trace_api.SpanKind = ..., attributes: types.Attributes = ..., links: Optional[Sequence[trace_api.Link]] = ..., start_time: Optional[int] = ..., record_exception: bool = ..., set_status_on_exception: bool = ...) -> trace_api.Span:
        ...
    


class TracerProvider(trace_api.TracerProvider):
    """See `opentelemetry.trace.TracerProvider`."""
    def __init__(self, sampler: Optional[sampling.Sampler] = ..., resource: Optional[Resource] = ..., shutdown_on_exit: bool = ..., active_span_processor: Union[SynchronousMultiSpanProcessor, ConcurrentMultiSpanProcessor, None] = ..., id_generator: Optional[IdGenerator] = ..., span_limits: Optional[SpanLimits] = ...) -> None:
        ...
    
    @property
    def resource(self) -> Resource:
        ...
    
    def get_tracer(self, instrumenting_module_name: str, instrumenting_library_version: typing.Optional[str] = ..., schema_url: typing.Optional[str] = ..., attributes: typing.Optional[types.Attributes] = ...) -> trace_api.Tracer:
        ...
    
    def add_span_processor(self, span_processor: SpanProcessor) -> None:
        """Registers a new :class:`SpanProcessor` for this `TracerProvider`.

        The span processors are invoked in the same order they are registered.
        """
        ...
    
    def shutdown(self): # -> None:
        """Shut down the span processors added to the tracer provider."""
        ...
    
    def force_flush(self, timeout_millis: int = ...) -> bool:
        """Requests the active span processor to process all spans that have not
        yet been processed.

        By default force flush is called sequentially on all added span
        processors. This means that span processors further back in the list
        have less time to flush their spans.
        To have span processors flush their spans in parallel it is possible to
        initialize the tracer provider with an instance of
        `ConcurrentMultiSpanProcessor` at the cost of using multiple threads.

        Args:
            timeout_millis: The maximum amount of time to wait for spans to be
                processed.

        Returns:
            False if the timeout is exceeded, True otherwise.
        """
        ...
    


